from collections.abc import Callable, Iterable, Sequence
from typing import Any, Protocol, TypeVar, overload
from typing_extensions import TypeVarTuple, Unpack

from zope.interface import Interface

_T = TypeVar("_T")
_Ts = TypeVarTuple("_Ts")

class _Attempt(Protocol):
    def __enter__(self) -> ITransaction: ...
    def __exit__(self, t: object, v: object, tb: object, /) -> bool | None: ...

class _DataManager(Protocol):
    @property
    def transaction_manager(self) -> ITransactionManager: ...
    def abort(self, transaction: ITransaction, /) -> object: ...
    def tpc_begin(self, transaction: ITransaction, /) -> object: ...
    def commit(self, transaction: ITransaction, /) -> object: ...
    def tpc_vote(self, transaction: ITransaction, /) -> object: ...
    def tpc_finish(self, transaction: ITransaction, /) -> object: ...
    def tpc_abort(self, transaction: ITransaction, /) -> object: ...
    def sortKey(self) -> str: ...

class _Synchronizer(Protocol):
    def beforeCompletion(self, transaction: ITransaction, /) -> object: ...
    def afterCompletion(self, transaction: ITransaction, /) -> object: ...
    def newTransaction(self, transaction: ITransaction, /) -> object: ...


class ITransactionManager(Interface):
    explicit: bool
    def begin() -> ITransaction: ...
    def get() -> ITransaction: ...
    def commit() -> object: ...
    def abort() -> object: ...
    def doom() -> object: ...
    def isDoomed() -> bool: ...
    def savepoint(optimistic: bool = False) -> ISavepoint: ...
    def registerSynch(synch: _Synchronizer) -> object: ...
    def unregisterSynch(synch: _Synchronizer) -> object: ...
    def clearSynchs() -> object: ...
    def registeredSynchs() -> bool: ...
    def attempts(number: int = 3) -> Iterable[_Attempt]: ...
    @overload
    def run(func: Callable[[], _T], tries: int = 3) -> _T: ...
    @overload
    def run(func: None = None, tries: int = 3) -> Callable[[Callable[[], _T]], _T]: ...
    @overload
    def run(tries: int, /) -> Callable[[Callable[[], _T]], _T]: ...

class ITransaction(Interface):
    user: str
    description: str
    extension: dict[str, Any]
    def commit() -> object: ...
    def abort() -> object: ...
    def doom() -> object: ...
    def savepoint(optimistic: bool = False) -> ISavepoint: ...
    def join(datamanager: _DataManager) -> object: ...
    def note(text: str) -> object: ...
    def setExtendedInfo(name: str, value: object) -> object: ...
    @overload
    def addBeforeCommitHook(hook: Callable[[], object], args: tuple[()] = (), kws: None = None) -> object: ...
    @overload
    def addBeforeCommitHook(hook: Callable[[Unpack[_Ts]], object], args: tuple[Unpack[_Ts]], kws: None = None) -> object: ...
    @overload
    def addBeforeCommitHook(hook: Callable[..., object], args: Sequence[Any], kws: dict[str, Any]) -> object: ...
    def getBeforeCommitHooks() -> Iterable[tuple[Callable[..., object], Sequence[Any], dict[str, Any]]]: ...
    @overload
    def addAfterCommitHook(hook: Callable[[bool], object], args: tuple[()] = (), kws: None = None) -> object: ...
    @overload
    def addAfterCommitHook(hook: Callable[[bool, Unpack[_Ts]], object], args: tuple[Unpack[_Ts]], kws: None = None) -> object: ...
    @overload
    def addAfterCommitHook(hook: Callable[[bool, Unpack[tuple[Any, ...]]], object], args: Sequence[Any], kws: dict[str, Any]) -> object: ...
    def getAfterCommitHooks() -> Iterable[tuple[Callable[[bool, Unpack[tuple[Any, ...]]], object], Sequence[Any], dict[str, Any]]]: ...
    @overload
    def addBeforeAbortHook(hook: Callable[[], object], args: tuple[()] = (), kws: None = None) -> object: ...
    @overload
    def addBeforeAbortHook(hook: Callable[[Unpack[_Ts]], object], args: tuple[Unpack[_Ts]], kws: None = None) -> object: ...
    @overload
    def addBeforeAbortHook(hook: Callable[..., object], args: Sequence[Any], kws: dict[str, Any]) -> object: ...
    def getBeforeAbortHooks() -> Iterable[tuple[Callable[..., object], Sequence[Any], dict[str, Any]]]: ...
    @overload
    def addAfterAbortHook(hook: Callable[[], object], args: tuple[()] = (), kws: None = None) -> object: ...
    @overload
    def addAfterAbortHook(hook: Callable[[Unpack[_Ts]], object], args: tuple[Unpack[_Ts]], kws: None = None) -> object: ...
    @overload
    def addAfterAbortHook(hook: Callable[..., object], args: Sequence[Any], kws: dict[str, Any]) -> object: ...
    def getAfterAbortHooks() -> Iterable[tuple[Callable[..., object], Sequence[Any], dict[str, Any]]]: ...
    def set_data(ob: object, data: object) -> object: ...
    def data(ob: object) -> Any: ...
    def isRetryableError(error: BaseException) -> bool: ...

class IDataManager(Interface):
    transaction_manager: ITransactionManager
    def abort(transaction: ITransaction) -> object: ...
    def tpc_begin(transaction: ITransaction) -> object: ...
    def commit(transaction: ITransaction) -> object: ...
    def tpc_vote(transaction: ITransaction) -> object: ...
    def tpc_finish(transaction: ITransaction) -> object: ...
    def tpc_abort(transaction: ITransaction) -> object: ...
    def sortKey() -> str: ...

class ISavepointDataManager(IDataManager):
    def savepoint() -> IDataManagerSavepoint: ...

class IRetryDataManager(IDataManager):
    def should_retry(exception: BaseException) -> bool: ...

class IDataManagerSavepoint(Interface):
    def rollback() -> object: ...

class ISavepoint(Interface):
    def rollback() -> object: ...
    valid: bool

class InvalidSavepointRollbackError(Exception): ...

class ISynchronizer(Interface):
    def beforeCompletion(transaction: ITransaction) -> object: ...
    def afterCompletion(transaction: ITransaction) -> object: ...
    def newTransaction(transaction: ITransaction) -> object: ...

class TransactionError(Exception): ...
class TransactionFailedError(TransactionError): ...
class DoomedTransaction(TransactionError): ...
class TransientError(TransactionError): ...
class NoTransaction(TransactionError): ...
class AlreadyInTransaction(TransactionError): ...
